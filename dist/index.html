<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Echarts Builder For Figma</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      
      body {
        font-family: system-ui, -apple-system, sans-serif;
        background: white;
        overflow: hidden;
        height: 100vh;
      }
      
      .main-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        min-width: 800px;
      }
      
      .header {
        background: white;
        border-bottom: 1px solid #ddd;
        padding: 16px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        min-height: 60px;
      }
      
      .header h2 {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
      }
      
      .header-buttons {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      
      .btn {
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        border: none;
      }
      
      .btn-primary {
        background: #000;
        color: white;
      }
      
      .btn-primary:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      
      .btn-outline {
        background: white;
        color: #000;
        border: 1px solid #000;
      }
      
      .main-content {
        display: flex;
        flex: 1;
        overflow: hidden;
        min-height: 0;
      }
      
      .chart-area {
        flex: 7;
        background: white;
        border-right: 1px solid #ddd;
        padding: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }
      
      .chart-container {
        width: 100%;
        height: 100%;
        max-width: 600px;
        max-height: 450px;
        min-width: 300px;
        min-height: 225px;
        border: 1px solid #eee;
        border-radius: 4px;
      }
      
      .controls {
        flex: 3;
        background: #f9f9f9;
        padding: 20px;
        overflow-y: auto;
        min-width: 350px;
      }
      
      .control-section {
        margin-bottom: 20px;
      }
      
      .control-section h3 {
        font-size: 14px;
        margin-bottom: 8px;
        color: #333;
      }
      
      .chart-types {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 6px;
      }
      
      .chart-type-btn {
        padding: 8px;
        text-align: center;
        font-size: 10px;
        border: 2px solid #ccc;
        background: white;
        border-radius: 4px;
        cursor: pointer;
      }
      
      .chart-type-btn.active {
        border-color: #000;
        background: #f5f5f5;
      }
      
      .input-group {
        display: flex;
        gap: 8px;
        margin-bottom: 8px;
      }
      
      .input-group input,
      .input-group select {
        padding: 6px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 12px;
      }
      
      .input-group input[type="text"] {
        flex: 1;
      }
      
      .checkbox-group {
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: 12px;
        margin-bottom: 4px;
      }
      
      .grid-2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
      
      .hidden {
        display: none !important;
      }
      
      .series-item {
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px;
        margin-bottom: 8px;
        background: white;
      }
      
      .series-controls {
        display: flex;
        gap: 4px;
        align-items: center;
        margin-bottom: 4px;
      }
      
      .series-controls input[type="text"] {
        flex: 1;
        padding: 4px;
        font-size: 12px;
      }
      
      .series-controls input[type="color"] {
        width: 24px;
        height: 24px;
        border: none;
        border-radius: 4px;
      }
      
      .series-controls select {
        padding: 4px;
        font-size: 11px;
      }
      
      .series-controls button {
        padding: 4px 8px;
        font-size: 11px;
        background: white;
        border: 1px solid #000;
        border-radius: 4px;
        cursor: pointer;
      }
      
      .series-data {
        width: 100%;
        height: 40px;
        padding: 4px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 11px;
        font-family: monospace;
        resize: none;
        margin-bottom: 4px;
      }
      
      .series-options {
        display: flex;
        gap: 8px;
        font-size: 11px;
      }
      
      .add-series-btn {
        width: 100%;
        padding: 8px;
        background: white;
        border: 1px solid #000;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }
      
      .options-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 8px;
        font-size: 12px;
      }
      
      .range-control {
        margin-bottom: 8px;
      }
      
      .range-control label {
        display: block;
        font-size: 12px;
        margin-bottom: 4px;
      }
      
      .range-control input[type="range"] {
        width: 100%;
      }

      .pie-slice-item {
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px;
        margin-bottom: 8px;
        background: white;
      }

      .pie-slice-controls {
        display: flex;
        gap: 4px;
        align-items: center;
        margin-bottom: 4px;
        width: 100%;
      }

      .pie-slice-controls input[type="text"] {
        flex: 2;
        min-width: 0;
        padding: 4px;
        font-size: 12px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      .pie-slice-controls input[type="number"] {
        width: 50px;
        flex-shrink: 0;
        padding: 4px;
        font-size: 12px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      .pie-slice-controls input[type="color"] {
        width: 24px;
        height: 24px;
        flex-shrink: 0;
        border: none;
        border-radius: 4px;
      }

      .pie-slice-controls button {
        width: 24px;
        height: 24px;
        flex-shrink: 0;
        padding: 0;
        font-size: 14px;
        line-height: 1;
        background: white;
        border: 1px solid #000;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .items-center {
        display: flex;
        align-items: center;
        gap: 4px;
      }
      .rotated-chart {
          display: inline-block;
          transform: rotate(90deg); 
          font-size: 1.2em;
          line-height: 1;
        }
    </style>
  </head>
  <body>
    <div class="main-container">
      <!-- Header -->
      <div class="header">
        <h2 class="items-center"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path fill="#000" d="M12 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12a12 12 0 0 0 12-12A12 12 0 0 0 12 0m-.792 5.307c2.192-.025 4.366 1.134 5.43 3.304c.909 1.852.878 3.61-.098 5.645c-.477.995-.487 1.06-.241 1.578c.214.452.727.779 1.221.779c.454 0 1.15-.586 1.252-1.054c.1-.454-.193-1.118-.607-1.377a10 10 0 0 1-.393-.255c-.129-.1.42-.38.741-.38c.687 0 1.247.526 1.375 1.29c.055.333.134.422.44.502c.859.222 1.297 1.451.755 2.116c-.22.27-.23.271-.305.042c-.267-.801-.666-1.12-1.403-1.12c-.319 0-.572.128-1.098.556c-1.006.82-1.866 1.303-2.907 1.632c-1.276.384-2.752.478-4.086.156c-2.162-.431-4.232-2.11-5.252-4.257C4.758 11.782 5.135 9 7.033 7.077a5.92 5.92 0 0 1 4.175-1.77" stroke-width="0.6" stroke="#000"/></svg> Echarts Builder For Figma</h2>
        <div class="header-buttons">
          <button id="export-btn" class="btn btn-primary">Export SVG to Canvas</button>
          <button id="minimize-btn" class="btn btn-outline">üîΩ Collapse</button>
        </div>
      </div>

      <!-- Main Content -->
      <div id="main-content" class="main-content">
        <!-- Chart Area -->
        <div class="chart-area">
          <div id="chart-container" class="chart-container"></div>
        </div>
        
        <!-- Controls -->
        <div class="controls">
          <!-- Chart Types -->
          <div class="control-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <h3 style="margin: 0;">üìà Chart Type</h3>
              <label class="checkbox-group" style="padding: 4px 8px; background: #f0f0f0; color: #333; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="dark-mode" > üåô Dark Mode
              </label>
            </div>
            <div class="chart-types">
              <button class="chart-type-btn" data-type="line">üìà Line</button>
              <button class="chart-type-btn" data-type="bar">üìä Column</button>
              <button class="chart-type-btn" data-type="horizontalBar"><span class="rotated-chart">üìä</span> Bar</button>
              <button class="chart-type-btn" data-type="area">üèûÔ∏è Area</button>
              <button class="chart-type-btn" data-type="scatter">·†Ö Scatter</button>
              <button class="chart-type-btn active" data-type="mixed">üîÄ Mixed</button>
              <button class="chart-type-btn" data-type="pie">‚óî Pie</button>
              <button class="chart-type-btn" data-type="doughnut">‚óé Donut</button>
            </div>
          </div>

          <!-- Title Controls -->
          <div class="control-section">
            <h3>üìù Title</h3>
            <div class="input-group">
              <input type="text" id="chart-title" placeholder="Chart title" value="Multi-Series Chart">
              <label class="checkbox-group">
                <input type="checkbox" id="show-title" checked> Show
              </label>
            </div>
            <div class="grid-2">
              <select id="title-align">
                <option value="left">Left</option>
                <option value="center" selected>Center</option>
                <option value="right">Right</option>
              </select>
              <select id="title-position">
                <option value="top" selected>Top</option>
                <option value="bottom">Bottom</option>
              </select>
            </div>
          </div>

          <!-- Legend Controls -->
          <div class="control-section">
            <h3>üè∑Ô∏è Legend</h3>
            <label class="checkbox-group">
              <input type="checkbox" id="show-legend" checked> Show Legend
            </label>
            <div class="grid-2">
              <select id="legend-position">
                <option value="top">Top</option>
                <option value="bottom" selected>Bottom</option>
                <option value="left">Left</option>
                <option value="right">Right</option>
              </select>
              <select id="legend-align">
                <option value="auto" selected>Auto</option>
                <option value="left">Left</option>
                <option value="center">Center</option>
                <option value="right">Right</option>
              </select>
            </div>
          </div>

          <!-- Series Management -->
          <div class="control-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <h3 style="margin: 0;">üìä Data Series</h3>
              <button id="randomize-data" style="padding: 4px 8px; background: #f0f0f0; color: #333; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 11px;">üé≤ Randomize</button>
            </div>
            <div id="series-list"></div>
            <div style="display: flex; gap: 8px;">
              <button class="add-series-btn" id="add-series" style="flex: 1;">+ Add Series</button>
            </div>
          </div>

          <!-- Axis Controls -->
          <div class="control-section">
            <h3>üìê Axis Controls</h3>
            <div class="options-grid">
              <label class="checkbox-group">
                <input type="checkbox" id="show-x-axis" checked> Show X Axis
              </label>
              <label class="checkbox-group">
                <input type="checkbox" id="show-y-axis" checked> Show Y Axis
              </label>
              <label class="checkbox-group">
                <input type="checkbox" id="show-x-lines"> X Grid
              </label>
              <label class="checkbox-group">
                <input type="checkbox" id="show-y-lines"> Y Grid
              </label>
            </div>
            <div style="margin-top: 8px;">
              <label style="display: block; font-size: 12px; margin-bottom: 4px;">X-Axis</label>
              <div style="display: flex; gap: 4px;">
                <button id="decrease-x-points-time" style="padding: 4px 8px; border: 1px solid #ccc; background: white; border-radius: 4px; cursor: pointer;">-</button>
                <select id="time-scale" style="flex: 1; padding: 6px; border: 1px solid #ccc; border-radius: 4px;">                
                  <option value="minute">Minute</option>
                  <option value="hour">Hour</option>
                  <option value="daily">Daily</option>
                  <option value="weekly">Weekly</option>
                  <option value="bi-weekly">Bi-Weekly</option>
                  <option value="monthly" selected>Monthly</option>
                  <option value="quarterly">Quarterly</option>
                  <option value="yearly">Yearly</option>
                  <option value="custom">Custom Labels</option>
                </select>
                <button id="increase-x-points-time" style="padding: 4px 8px; border: 1px solid #ccc; background: white; border-radius: 4px; cursor: pointer;">+</button>
              </div>
            </div>
            <div id="custom-x-axis-controls" style="margin-top: 8px; display: none;">
              <label style="display: block; font-size: 12px; margin-bottom: 4px;">Custom X-Axis Labels</label>
              <div style="display: flex; gap: 4px; margin-bottom: 4px;">
                <button id="decrease-x-points" style="padding: 4px 8px; border: 1px solid #ccc; background: white; border-radius: 4px; cursor: pointer;">-</button>
                <input type="text" id="custom-x-labels" placeholder="Jan,Feb,Mar,Apr,May,Jun" style="flex: 1; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;">
                <button id="increase-x-points" style="padding: 4px 8px; border: 1px solid #ccc; background: white; border-radius: 4px; cursor: pointer;">+</button>
              </div>
              <div style="font-size: 11px; color: #666; margin-bottom: 4px;">Enter comma-separated values or use +/- to adjust points</div>
            </div>
          </div>

          <!-- Chart-Specific Controls -->
          <div class="control-section" id="bar-controls" style="display: none;">
            <h3>üìä Bar Chart Options</h3>
            <div class="grid-2">
              <div>
                <label style="display: block; font-size: 12px; margin-bottom: 4px;">Border Radius</label>
                <input type="number" id="bar-border-radius" min="0" max="20" value="0" 
                  style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px;">
              </div>
              <div>
                <label style="display: block; font-size: 12px; margin-bottom: 4px;">Corner Style</label>
                <select id="bar-corner-style" style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px;">
                  <option value="all">All Corners</option>
                  <option value="top">Top Only</option>
                  <option value="bottom">Bottom Only</option>
                </select>
              </div>
            </div>
          </div>

          <!-- Pie/Doughnut Controls -->
          <div class="control-section" id="pie-controls" style="display: none;">
            <h3>ü•ß Pie/Doughnut Data</h3>
            <div id="pie-data-list"></div>
            <button class="add-series-btn" id="add-pie-slice" style="width: 100%; margin-bottom: 16px;">+ Add Slice</button>
            
            <div id="doughnut-options" style="display: none;">
              <h4 style="font-size: 12px; margin-bottom: 8px;">üç© Doughnut Options</h4>
              <div class="grid-2">
                <div>
                  <label style="display: block; font-size: 12px; margin-bottom: 4px;">Inner Radius (%)</label>
                  <input type="number" id="doughnut-inner-radius" min="10" max="80" value="40" 
                    style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px;">
                </div>
                <div>
                  <label style="display: block; font-size: 12px; margin-bottom: 4px;">Outer Radius (%)</label>
                  <input type="number" id="doughnut-outer-radius" min="30" max="90" value="70" 
                    style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px;">
                </div>
              </div>
            </div>
          </div>

          <!-- Chart Options -->
          <div class="control-section">
            <h3>‚öôÔ∏è Options</h3>
            <div class="options-grid">
              <label class="checkbox-group">
                <input type="checkbox" id="show-data-labels"> Data Labels
              </label>
              <label class="checkbox-group">
                <input type="checkbox" id="stack-series"> Stack Series
              </label>
              <label class="checkbox-group">
                <input type="checkbox" id="smooth-line"> Smooth Lines
              </label>
            </div>
            <div class="grid-2">
              <div>
                <label style="display: block; font-size: 12px; margin-bottom: 4px;">Width (px)</label>
                <input type="number" id="chart-width" min="300" max="1200" value="600" 
                  style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px;">
              </div>
              <div>
                <label style="display: block; font-size: 12px; margin-bottom: 4px;">Height (px)</label>
                <input type="number" id="chart-height" min="200" max="900" value="450" 
                  style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px;">
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Global state
      let chart = null;
      let isMinimized = false;
      let currentChartType = 'mixed';
      let isDarkMode = false;
      let colorMemory = [];
      let seriesData = [
        { name: 'Sales', type: 'bar', data: [120, 200, 150, 80, 70, 110], color: '#5470c6', visible: true, pointColors: [] },
        { name: 'Profit', type: 'line', data: [20, 50, 30, 15, 10, 25], color: '#91cc75', visible: true, pointColors: [] }
      ];
      let categories = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'];
      let pieData = [
        { name: 'Category A', value: 30, color: '#5470c6' },
        { name: 'Category B', value: 25, color: '#91cc75' },
        { name: 'Category C', value: 20, color: '#fac858' },
        { name: 'Category D', value: 15, color: '#ee6666' },
        { name: 'Category E', value: 10, color: '#73c0de' }
      ];

      // Color memory functions
      function saveColorMemory() {
        try {
          localStorage.setItem('figma-echarts-colors', JSON.stringify(colorMemory));
        } catch (e) {
          console.warn('Could not save color memory:', e);
        }
      }

      function loadColorMemory() {
        try {
          const saved = localStorage.getItem('figma-echarts-colors');
          if (saved) {
            colorMemory = JSON.parse(saved);
          }
        } catch (e) {
          console.warn('Could not load color memory:', e);
          colorMemory = [];
        }
      }

      function addToColorMemory(color) {
        // Remove color if it already exists
        const index = colorMemory.indexOf(color);
        if (index > -1) {
          colorMemory.splice(index, 1);
        }
        
        // Add color to front of array
        colorMemory.unshift(color);
        
        // Keep only last 12 colors
        if (colorMemory.length > 12) {
          colorMemory = colorMemory.slice(0, 12);
        }
        
        saveColorMemory();
      }

      function getNextColor() {
        const defaultColors = ['#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de', '#3ba272', '#fc8452', '#9a60b4'];
        
        // Get current colors in use
        const currentColors = seriesData.map(s => s.color);
        
        // Try remembered colors first (skip colors already in use)
        for (const color of colorMemory) {
          if (!currentColors.includes(color)) {
            return color;
          }
        }
        
        // Fall back to default colors (skip colors already in use)
        for (const color of defaultColors) {
          if (!currentColors.includes(color)) {
            return color;
          }
        }
        
        // If all colors are in use, return most recent from memory or first default
        return colorMemory.length > 0 ? colorMemory[0] : defaultColors[0];
      }

      // Load ECharts and initialize
      function initializePlugin() {
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js';
        script.onload = function() {
          loadColorMemory(); // Load saved colors
          setupEventListeners();
          initializeChart();
          renderSeriesList();
          renderPieDataList();
          updateChartSpecificControls();
          updateChartTypeUI(); // Set initial chart type UI based on data
          console.log('‚úÖ Plugin initialized successfully');
        };
        script.onerror = function() {
          console.error('‚ùå Failed to load ECharts');
          document.getElementById('chart-container').innerHTML = 
            '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">ECharts failed to load</div>';
        };
        document.head.appendChild(script);
      }

      function setupEventListeners() {
        // Chart type buttons
        document.querySelectorAll('.chart-type-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            document.querySelectorAll('.chart-type-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentChartType = btn.dataset.type;
            
            // Don't reset series types for mixed - allow individual types to remain
            if (currentChartType !== 'mixed') {
              resetSeriesToChartType();
            }
            
            updateChartSpecificControls();
            updateChart();
          });
        });

        // Title controls
        document.getElementById('chart-title').addEventListener('input', updateChart);
        document.getElementById('show-title').addEventListener('change', updateChart);
        document.getElementById('title-align').addEventListener('change', updateChart);
        document.getElementById('title-position').addEventListener('change', updateChart);

        // Legend controls
        document.getElementById('show-legend').addEventListener('change', updateChart);
        document.getElementById('legend-position').addEventListener('change', updateChart);
        document.getElementById('legend-align').addEventListener('change', updateChart);

        // Axis controls
        document.getElementById('show-x-axis').addEventListener('change', updateChart);
        document.getElementById('show-y-axis').addEventListener('change', updateChart);
        document.getElementById('show-x-lines').addEventListener('change', updateChart);
        document.getElementById('show-y-lines').addEventListener('change', updateChart);
        document.getElementById('time-scale').addEventListener('change', updateTimeScale);
        document.getElementById('custom-x-labels').addEventListener('input', updateCustomXLabels);
        document.getElementById('increase-x-points').addEventListener('click', increaseXAxisPoints);
        document.getElementById('decrease-x-points').addEventListener('click', decreaseXAxisPoints);
        document.getElementById('increase-x-points-time').addEventListener('click', increaseXAxisPointsTime);
        document.getElementById('decrease-x-points-time').addEventListener('click', decreaseXAxisPointsTime);

        // Options
        document.getElementById('show-data-labels').addEventListener('change', updateChart);
        document.getElementById('stack-series').addEventListener('change', updateChart);
        document.getElementById('smooth-line').addEventListener('change', updateChart);
        document.getElementById('dark-mode').addEventListener('change', toggleDarkMode);

        // Chart-specific controls
        document.getElementById('bar-border-radius').addEventListener('input', updateChart);
        document.getElementById('bar-corner-style').addEventListener('change', updateChart);
        document.getElementById('doughnut-inner-radius').addEventListener('input', updateChart);
        document.getElementById('doughnut-outer-radius').addEventListener('input', updateChart);

        // Chart dimensions
        document.getElementById('chart-width').addEventListener('input', updateChartDimensions);
        document.getElementById('chart-height').addEventListener('input', updateChartDimensions);

        // Header buttons
        document.getElementById('export-btn').addEventListener('click', exportChart);
        document.getElementById('minimize-btn').addEventListener('click', toggleMinimize);
        
        // Series buttons
        document.getElementById('add-series').addEventListener('click', addSeries);
        document.getElementById('randomize-data').addEventListener('click', randomizeAllData);
        document.getElementById('add-pie-slice').addEventListener('click', addPieSlice);
      }

      function initializeChart() {
        if (typeof echarts === 'undefined') return;
        
        const container = document.getElementById('chart-container');
        const theme = isDarkMode ? 'dark' : null;
        chart = echarts.init(container, theme, { renderer: 'svg' });
        updateChart();
        
        // Handle window resize
        window.addEventListener('resize', () => {
          if (chart && !isMinimized) {
            chart.resize();
          }
        });
      }

      function generateChartOption() {
        const title = document.getElementById('chart-title').value;
        const showTitle = document.getElementById('show-title').checked;
        const titleAlign = document.getElementById('title-align').value;
        const titlePosition = document.getElementById('title-position').value;
        
        const showLegend = document.getElementById('show-legend').checked;
        const legendPosition = document.getElementById('legend-position').value;
        const legendAlign = document.getElementById('legend-align').value;
        
        // Get current chart dimensions
        const chartWidth = parseInt(document.getElementById('chart-width').value);
        const chartHeight = parseInt(document.getElementById('chart-height').value);
        
        const showXAxis = document.getElementById('show-x-axis').checked;
        const showYAxis = document.getElementById('show-y-axis').checked;
        const showDataLabels = document.getElementById('show-data-labels').checked;
        const stackSeries = document.getElementById('stack-series').checked;
        const smoothLine = document.getElementById('smooth-line').checked;
        const showXLines = document.getElementById('show-x-lines').checked;
        const showYLines = document.getElementById('show-y-lines').checked;

        // Chart-specific options
        const barBorderRadius = parseInt(document.getElementById('bar-border-radius').value);
        const barCornerStyle = document.getElementById('bar-corner-style').value;
        const doughnutInnerRadius = parseInt(document.getElementById('doughnut-inner-radius').value);
        const doughnutOuterRadius = parseInt(document.getElementById('doughnut-outer-radius').value);

        const option = {
          title: showTitle ? {
            show: true,
            text: title,
            left: titleAlign,
            top: titlePosition === 'bottom' ? 'bottom' : 20,
            bottom: titlePosition === 'bottom' ? 20 : undefined,
            textStyle: { fontSize: 16, fontWeight: 'bold' }
          } : { show: false },
          
          legend: showLegend ? {
            show: true,
            [legendPosition]: legendPosition === 'top' ? 15 : (legendPosition === 'bottom' ? 15 : 15),
            left: legendPosition === 'top' || legendPosition === 'bottom' ? 'center' : undefined,
            orient: legendPosition === 'left' || legendPosition === 'right' ? 'vertical' : 'horizontal',
            align: legendAlign === 'auto' ? 'auto' : legendAlign,
            itemWidth: 14,
            itemHeight: 14,
            textStyle: { fontSize: 12 }
          } : { show: false },
          
          grid: {
            left: legendPosition === 'left' ? Math.max(100, chartWidth * 0.15) : Math.max(60, chartWidth * 0.08),
            right: legendPosition === 'right' ? Math.max(100, chartWidth * 0.15) : Math.max(60, chartWidth * 0.08),
            top: showTitle && titlePosition === 'top' ? Math.max(80, chartHeight * 0.15) : 
                 (legendPosition === 'top' ? Math.max(60, chartHeight * 0.12) : Math.max(40, chartHeight * 0.08)),
            bottom: showTitle && titlePosition === 'bottom' ? Math.max(80, chartHeight * 0.15) : 
                    (legendPosition === 'bottom' ? Math.max(60, chartHeight * 0.12) : Math.max(40, chartHeight * 0.08)),
            containLabel: true
          },
          
          tooltip: {
            trigger: 'axis',
            axisPointer: { type: 'cross' }
          }
        };

        // Handle pie and doughnut charts
        if (currentChartType === 'pie' || currentChartType === 'doughnut') {
          let radius;
          if (currentChartType === 'doughnut') {
            radius = [`${doughnutInnerRadius}%`, `${doughnutOuterRadius}%`];
          } else {
            radius = '60%';
          }
          
          const chartPieData = pieData.map(slice => ({
            name: slice.name,
            value: slice.value,
            itemStyle: { color: slice.color }
          }));
          
          // Calculate pie chart center based on title and legend positions
          let centerY = '50%';
          if (showTitle && titlePosition === 'top') {
            centerY = '55%';
          } else if (showTitle && titlePosition === 'bottom') {
            centerY = '45%';
          }
          if (showLegend && legendPosition === 'top') {
            centerY = '55%';
          } else if (showLegend && legendPosition === 'bottom') {
            centerY = '45%';
          }

          option.series = [{
            type: 'pie',
            radius: radius,
            center: ['50%', centerY],
            data: chartPieData,
            label: { 
              show: showDataLabels, 
              formatter: '{b}: {c} ({d}%)',
              fontSize: 12
            },
            emphasis: {
              itemStyle: {
                shadowBlur: 10,
                shadowOffsetX: 0,
                shadowColor: 'rgba(0, 0, 0, 0.5)'
              }
            }
          }];
          
          return option;
        }

        // Handle other chart types
        const isHorizontalBar = currentChartType === 'horizontalBar';
        
        option.xAxis = {
          show: showXAxis,
          type: isHorizontalBar ? 'value' : 'category',
          data: isHorizontalBar ? undefined : categories,
          splitLine: { show: showXLines }
        };
        
        option.yAxis = {
          show: showYAxis,
          type: isHorizontalBar ? 'category' : 'value',
          data: isHorizontalBar ? categories : undefined,
          splitLine: { show: showYLines }
        };

        option.series = seriesData
          .filter(series => series.visible)
          .map((series) => {
            // Allow individual series types for all chart types, not just mixed
            let seriesType = series.type;
            const echartsType = seriesType === 'horizontalBar' ? 'bar' : 
                              seriesType === 'area' ? 'line' : seriesType;
            
            // Check if series has individual point colors
            const hasPointColors = series.pointColors && series.pointColors.length > 0;
            let chartData = series.data;
            
            if (hasPointColors) {
              // Convert data to objects with individual colors
              chartData = series.data.map((value, index) => ({
                value: value,
                itemStyle: { color: series.pointColors[index] || series.color }
              }));
            }
            
            const seriesConfig = {
              name: series.name,
              type: echartsType,
              data: chartData,
              itemStyle: hasPointColors ? {} : { color: series.color },
              lineStyle: { color: series.color },
              label: { show: showDataLabels, position: echartsType === 'line' ? 'top' : 'inside' }
            };

            // Handle bar border radius
            if (echartsType === 'bar' && barBorderRadius > 0) {
              let borderRadius;
              if (barCornerStyle === 'top') {
                borderRadius = isHorizontalBar ? [0, barBorderRadius, barBorderRadius, 0] : [barBorderRadius, barBorderRadius, 0, 0];
              } else if (barCornerStyle === 'bottom') {
                borderRadius = isHorizontalBar ? [barBorderRadius, 0, 0, barBorderRadius] : [0, 0, barBorderRadius, barBorderRadius];
              } else {
                borderRadius = barBorderRadius;
              }
              seriesConfig.itemStyle.borderRadius = borderRadius;
            }
            
            if (echartsType === 'line' || seriesType === 'area') {
              seriesConfig.smooth = smoothLine;
              if (seriesType === 'area') {
                seriesConfig.areaStyle = { color: series.color, opacity: 0.6 };
              }
            }
            
            if (stackSeries && (echartsType === 'bar' || seriesType === 'area' || echartsType === 'line')) {
              seriesConfig.stack = 'total';
            }
            
            return seriesConfig;
          });

        return option;
      }

      function updateChart() {
        if (!chart) return;
        const option = generateChartOption();
        chart.setOption(option, true);
        updateChartTypeUI();
      }

      function updateChartTypeUI() {
        // Check if we have mixed chart types
        const visibleSeries = seriesData.filter(series => series.visible);
        const uniqueTypes = [...new Set(visibleSeries.map(series => series.type))];
        
        // Auto-select Mixed if we have different chart types
        if (uniqueTypes.length > 1) {
          currentChartType = 'mixed';
        } else if (uniqueTypes.length === 1 && currentChartType === 'mixed') {
          // If all series are the same type and we're currently on mixed, switch to that type
          currentChartType = uniqueTypes[0];
        }
        
        // Update UI buttons
        document.querySelectorAll('.chart-type-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.type === currentChartType);
        });
      }

      function updateChartDimensions() {
        const width = parseInt(document.getElementById('chart-width').value);
        const height = parseInt(document.getElementById('chart-height').value);
        const container = document.getElementById('chart-container');
        container.style.maxWidth = `${width}px`;
        container.style.maxHeight = `${height}px`;
        if (chart) {
          setTimeout(() => chart.resize(), 100);
        }
      }

      function toggleDarkMode() {
        isDarkMode = document.getElementById('dark-mode').checked;
        if (chart) {
          chart.dispose();
          initializeChart();
        }
      }

      function randomizeAllData() {
        seriesData.forEach(series => {
          series.data = generateRandomData(categories.length);
        });
        renderSeriesList();
        updateChart();
      }

      function generateRandomData(length, min = 10, max = 200) {
        return Array.from({ length }, () => Math.floor(Math.random() * (max - min + 1)) + min);
      }

      function updateChartSpecificControls() {
        // Hide all specific controls first
        document.getElementById('bar-controls').style.display = 'none';
        document.getElementById('pie-controls').style.display = 'none';
        document.getElementById('doughnut-options').style.display = 'none';
        
        // Hide/show sections based on chart type
        const isXYChart = !['pie', 'doughnut'].includes(currentChartType);
        
        // Hide series and axis controls for pie/doughnut charts
        const allSections = document.querySelectorAll('.control-section');
        allSections.forEach(section => {
          const h3 = section.querySelector('h3');
          if (h3) {
            if (h3.textContent.includes('üìä Data Series') || h3.textContent.includes('üìê Axis Controls')) {
              section.style.display = isXYChart ? 'block' : 'none';
            }
          }
        });
        
        // Show relevant controls based on chart type
        if (currentChartType === 'bar' || currentChartType === 'horizontalBar') {
          document.getElementById('bar-controls').style.display = 'block';
        } else if (currentChartType === 'pie' || currentChartType === 'doughnut') {
          document.getElementById('pie-controls').style.display = 'block';
          if (currentChartType === 'doughnut') {
            document.getElementById('doughnut-options').style.display = 'block';
          }
          renderPieDataList();
        }
      }

      function resetSeriesToChartType() {
        // Don't reset for mixed type - it's meant to have different types
        if (currentChartType === 'mixed') return;
        
        // Reset all series to match the new chart type
        seriesData.forEach(series => {
          series.type = currentChartType;
        });
        
        // Re-render series list to show updated types
        renderSeriesList();
      }

      function generateTimeLabels(scale, count = 6) {
        const now = new Date();
        const labels = [];
        
        switch (scale) {
          case 'minute':
            for (let i = 0; i < count; i++) {
              const time = new Date(now.getTime() + i * 60000); // 1 minute intervals
              labels.push(time.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }));
            }
            break;
          case 'hour':
            for (let i = 0; i < count; i++) {
              const time = new Date(now.getTime() + i * 3600000); // 1 hour intervals
              labels.push(time.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }));
            }
            break;
          case 'daily':
            for (let i = 0; i < count; i++) {
              const date = new Date(now.getTime() + i * 86400000); // 1 day intervals
              labels.push(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
            }
            break;
          case 'weekly':
            for (let i = 0; i < count; i++) {
              const date = new Date(now.getTime() + i * 604800000); // 1 week intervals
              labels.push(`Week ${i + 1}`);
            }
            break;
          case 'bi-weekly':
            for (let i = 0; i < count; i++) {
              const date = new Date(now.getTime() + i * 1209600000); // 2 week intervals
              labels.push(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
            }
            break;
          case 'monthly':
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            for (let i = 0; i < count; i++) {
              const monthIndex = (now.getMonth() + i) % 12;
              const year = now.getFullYear() + Math.floor((now.getMonth() + i) / 12);
              labels.push(`${months[monthIndex]} ${year}`);
            }
            break;
          case 'quarterly':
            for (let i = 0; i < count; i++) {
              const quarter = Math.floor((now.getMonth() + i * 3) / 3) % 4 + 1;
              const year = now.getFullYear() + Math.floor((now.getMonth() + i * 3) / 12);
              labels.push(`Q${quarter} ${year}`);
            }
            break;
          case 'yearly':
            for (let i = 0; i < count; i++) {
              labels.push(`${now.getFullYear() + i}`);
            }
            break;
          default:
            return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun']; // Default custom labels
        }
        
        return labels;
      }

      function updateTimeScale() {
        const scale = document.getElementById('time-scale').value;
        const customControls = document.getElementById('custom-x-axis-controls');
        
        if (scale === 'custom') {
          customControls.style.display = 'block';
          // Update the input field with current categories
          document.getElementById('custom-x-labels').value = categories.join(',');
        } else {
          customControls.style.display = 'none';
          categories = generateTimeLabels(scale, categories.length);
          // Update all series data to match new category count
          seriesData.forEach(series => {
            if (series.data.length !== categories.length) {
              if (series.data.length < categories.length) {
                // Extend series data
                const lastValue = series.data[series.data.length - 1] || 50;
                while (series.data.length < categories.length) {
                  series.data.push(Math.floor(lastValue + (Math.random() - 0.5) * 20));
                  // Extend point colors if they exist
                  if (series.pointColors && series.pointColors.length > 0) {
                    series.pointColors.push(series.color);
                  }
                }
              } else {
                // Truncate series data
                series.data = series.data.slice(0, categories.length);
                // Truncate point colors if they exist
                if (series.pointColors && series.pointColors.length > 0) {
                  series.pointColors = series.pointColors.slice(0, categories.length);
                }
              }
            }
          });
          renderSeriesList();
          updateChart();
        }
      }

      function updateCustomXLabels() {
        const input = document.getElementById('custom-x-labels').value;
        if (input.trim()) {
          const newCategories = input.split(',').map(label => label.trim()).filter(label => label);
          if (newCategories.length > 0) {
            categories = newCategories;
            // Adjust series data to match new category count
            seriesData.forEach(series => {
              if (series.data.length !== categories.length) {
                if (series.data.length < categories.length) {
                  // Extend series data
                  const lastValue = series.data[series.data.length - 1] || 50;
                  while (series.data.length < categories.length) {
                    series.data.push(Math.floor(lastValue + (Math.random() - 0.5) * 20));
                    // Extend point colors if they exist
                    if (series.pointColors && series.pointColors.length > 0) {
                      series.pointColors.push(series.color);
                    }
                  }
                } else {
                  // Truncate series data
                  series.data = series.data.slice(0, categories.length);
                  // Truncate point colors if they exist
                  if (series.pointColors && series.pointColors.length > 0) {
                    series.pointColors = series.pointColors.slice(0, categories.length);
                  }
                }
              }
            });
            renderSeriesList();
            updateChart();
          }
        }
      }

      function increaseXAxisPoints() {
        const currentCount = categories.length;
        const timeScale = document.getElementById('time-scale').value;
        
        if (timeScale === 'custom') {
          // For custom labels, add generic point
          categories.push(`Point ${currentCount + 1}`);
          document.getElementById('custom-x-labels').value = categories.join(',');
        } else {
          // For time scales, regenerate with more points
          categories = generateTimeLabels(timeScale, currentCount + 1);
        }
        
        // Extend all series data
        seriesData.forEach(series => {
          const lastValue = series.data[series.data.length - 1] || 50;
          series.data.push(Math.floor(lastValue + (Math.random() - 0.5) * 20));
          // Extend point colors if they exist
          if (series.pointColors && series.pointColors.length > 0) {
            series.pointColors.push(series.color);
          }
        });
        
        renderSeriesList();
        updateChart();
      }

      function decreaseXAxisPoints() {
        if (categories.length <= 1) return; // Don't allow removing all points
        
        const currentCount = categories.length;
        const timeScale = document.getElementById('time-scale').value;
        
        if (timeScale === 'custom') {
          // For custom labels, remove last point
          categories.pop();
          document.getElementById('custom-x-labels').value = categories.join(',');
        } else {
          // For time scales, regenerate with fewer points
          categories = generateTimeLabels(timeScale, currentCount - 1);
        }
        
        // Truncate all series data
        seriesData.forEach(series => {
          series.data.pop();
          // Truncate point colors if they exist
          if (series.pointColors && series.pointColors.length > 0) {
            series.pointColors.pop();
          }
        });
        
        renderSeriesList();
        updateChart();
      }

      function increaseXAxisPointsTime() {
        const currentCount = categories.length;
        const timeScale = document.getElementById('time-scale').value;
        
        if (timeScale === 'custom') {
          // Switch to custom mode
          categories.push(`Point ${currentCount + 1}`);
          document.getElementById('custom-x-labels').value = categories.join(',');
          updateTimeScale(); // This will show custom controls
        } else {
          // For time scales, regenerate with more points
          categories = generateTimeLabels(timeScale, currentCount + 1);
        }
        
        // Extend all series data
        seriesData.forEach(series => {
          const lastValue = series.data[series.data.length - 1] || 50;
          series.data.push(Math.floor(lastValue + (Math.random() - 0.5) * 20));
          // Extend point colors if they exist
          if (series.pointColors && series.pointColors.length > 0) {
            series.pointColors.push(series.color);
          }
        });
        
        renderSeriesList();
        updateChart();
      }

      function decreaseXAxisPointsTime() {
        if (categories.length <= 1) return; // Don't allow removing all points
        
        const currentCount = categories.length;
        const timeScale = document.getElementById('time-scale').value;
        
        if (timeScale === 'custom') {
          // For custom labels, remove last point
          categories.pop();
          document.getElementById('custom-x-labels').value = categories.join(',');
        } else {
          // For time scales, regenerate with fewer points
          categories = generateTimeLabels(timeScale, currentCount - 1);
        }
        
        // Truncate all series data
        seriesData.forEach(series => {
          series.data.pop();
          // Truncate point colors if they exist
          if (series.pointColors && series.pointColors.length > 0) {
            series.pointColors.pop();
          }
        });
        
        renderSeriesList();
        updateChart();
      }

      function renderPieDataList() {
        const container = document.getElementById('pie-data-list');
        container.innerHTML = '';
        
        pieData.forEach((slice, index) => {
          const sliceDiv = document.createElement('div');
          sliceDiv.className = 'pie-slice-item';
          sliceDiv.innerHTML = `
            <div class="pie-slice-controls">
              <input type="text" value="${slice.name}" onchange="updatePieName(${index}, this.value)" placeholder="Category name">
              <input type="number" value="${slice.value}" onchange="updatePieValue(${index}, parseInt(this.value))" min="0" placeholder="Value">
              <input type="color" value="${slice.color}" onchange="updatePieColor(${index}, this.value)">
              <button onclick="removePieSlice(${index})">√ó</button>
            </div>
          `;
          container.appendChild(sliceDiv);
        });
      }

      function addPieSlice() {
        const colors = ['#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de', '#3ba272', '#fc8452', '#9a60b4'];
        pieData.push({
          name: `Category ${pieData.length + 1}`,
          value: 10,
          color: colors[pieData.length % colors.length]
        });
        renderPieDataList();
        updateChart();
      }

      function removePieSlice(index) {
        pieData.splice(index, 1);
        renderPieDataList();
        updateChart();
      }

      function updatePieName(index, name) {
        pieData[index].name = name;
        updateChart();
      }

      function updatePieValue(index, value) {
        pieData[index].value = value;
        updateChart();
      }

      function updatePieColor(index, color) {
        pieData[index].color = color;
        addToColorMemory(color); // Remember this color
        updateChart();
      }

      function generatePointColorInputs(series, seriesIndex) {
        const inputs = [];
        for (let i = 0; i < series.data.length; i++) {
          const color = series.pointColors[i] || series.color;
          const label = categories[i] || `Point ${i + 1}`;
          inputs.push(`
            <div style="text-align: center;">
              <div style="font-size: 9px; margin-bottom: 2px; overflow: hidden; white-space: nowrap;">${label}</div>
              <input type="color" value="${color}" 
                onchange="updatePointColor(${seriesIndex}, ${i}, this.value)"
                style="width: 28px; height: 20px; border: none; border-radius: 4px; cursor: pointer;">
            </div>
          `);
        }
        return inputs.join('');
      }

      function renderSeriesList() {
        const container = document.getElementById('series-list');
        container.innerHTML = '';
        
        seriesData.forEach((series, index) => {
          const seriesDiv = document.createElement('div');
          seriesDiv.className = 'series-item';
          seriesDiv.innerHTML = `
            <div class="series-controls">
              <input type="text" value="${series.name}" onchange="updateSeriesName(${index}, this.value)">
              <input type="color" value="${series.color}" onchange="updateSeriesColor(${index}, this.value)" title="Default series color">
              <select onchange="updateSeriesType(${index}, this.value)">
                <option value="line" ${series.type === 'line' ? 'selected' : ''}>Line</option>
                <option value="bar" ${series.type === 'bar' ? 'selected' : ''}>Bar</option>
                <option value="horizontalBar" ${series.type === 'horizontalBar' ? 'selected' : ''}>H-Bar</option>
                <option value="area" ${series.type === 'area' ? 'selected' : ''}>Area</option>
                <option value="scatter" ${series.type === 'scatter' ? 'selected' : ''}>Scatter</option>
              </select>
              <button onclick="togglePointColors(${index})" title="Toggle individual point colors">üé®</button>
              <button onclick="removeSeries(${index})">√ó</button>
            </div>
            <textarea class="series-data" placeholder="[10, 20, 30, 40, 50]" 
              onchange="updateSeriesData(${index}, this.value)">${JSON.stringify(series.data)}</textarea>
            <div class="series-options">
              <label class="checkbox-group">
                <input type="checkbox" ${series.visible ? 'checked' : ''} 
                  onchange="updateSeriesVisible(${index}, this.checked)"> Visible
              </label>
            </div>
            <div id="point-colors-${index}" class="point-colors" style="display: none; margin-top: 4px;">
              <div style="font-size: 11px; margin-bottom: 4px; color: #666;">Individual Point Colors:</div>
              <div class="point-colors-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(30px, 1fr)); gap: 4px;">
                ${generatePointColorInputs(series, index)}
              </div>
            </div>
          `;
          container.appendChild(seriesDiv);
        });
      }

      function addSeries() {
        // Use current chart type, but default to 'line' if mixed or pie/doughnut
        let newSeriesType = currentChartType;
        if (currentChartType === 'mixed' || currentChartType === 'pie' || currentChartType === 'doughnut') {
          newSeriesType = 'line'; // Default fallback for mixed/pie charts
        }
        
        // Get color from memory or use intelligent fallback
        const newColor = getNextColor();
        
        seriesData.push({
          name: `Series ${seriesData.length + 1}`,
          type: newSeriesType,
          data: generateRandomData(categories.length, 10, 100),
          color: newColor,
          visible: true,
          pointColors: []
        });
        renderSeriesList();
        updateChart();
      }

      function removeSeries(index) {
        seriesData.splice(index, 1);
        renderSeriesList();
        updateChart();
      }

      function updateSeriesName(index, name) {
        seriesData[index].name = name;
        updateChart();
      }

      function updateSeriesColor(index, color) {
        seriesData[index].color = color;
        addToColorMemory(color); // Remember this color
        updateChart();
      }

      function updateSeriesType(index, type) {
        seriesData[index].type = type;
        updateChart(); // This will call updateChartTypeUI() automatically
      }

      function updateSeriesData(index, dataStr) {
        try {
          const data = JSON.parse(dataStr);
          seriesData[index].data = data;
          updateChart();
        } catch (e) {
          console.warn('Invalid JSON data');
        }
      }

      function updateSeriesVisible(index, visible) {
        seriesData[index].visible = visible;
        updateChart(); // This will call updateChartTypeUI() automatically
      }


      function togglePointColors(seriesIndex) {
        const pointColorsDiv = document.getElementById(`point-colors-${seriesIndex}`);
        const isHidden = pointColorsDiv.style.display === 'none';
        
        if (isHidden) {
          // Initialize point colors if not set
          const series = seriesData[seriesIndex];
          if (!series.pointColors || series.pointColors.length === 0) {
            series.pointColors = new Array(series.data.length).fill('').map(() => series.color);
          }
          pointColorsDiv.style.display = 'block';
          // Refresh the point color inputs
          const grid = pointColorsDiv.querySelector('.point-colors-grid');
          grid.innerHTML = generatePointColorInputs(series, seriesIndex);
        } else {
          pointColorsDiv.style.display = 'none';
        }
      }

      function updatePointColor(seriesIndex, pointIndex, color) {
        if (!seriesData[seriesIndex].pointColors) {
          seriesData[seriesIndex].pointColors = new Array(seriesData[seriesIndex].data.length).fill(seriesData[seriesIndex].color);
        }
        seriesData[seriesIndex].pointColors[pointIndex] = color;
        addToColorMemory(color); // Remember this color
        updateChart();
      }

      function toggleMinimize() {
        isMinimized = !isMinimized;
        const mainContent = document.getElementById('main-content');
        const minimizeBtn = document.getElementById('minimize-btn');
        const exportBtn = document.getElementById('export-btn');
        
        if (isMinimized) {
          mainContent.classList.add('hidden');
          minimizeBtn.textContent = '‚ñ∂Ô∏è Expand';
          exportBtn.disabled = true;
          
          // Send message to Figma to resize
          if (typeof parent !== 'undefined' && parent !== window) {
            parent.postMessage({
              pluginMessage: { type: 'minimize' }
            }, '*');
          }
        } else {
          mainContent.classList.remove('hidden');
          minimizeBtn.textContent = 'üîΩ Collapse';
          exportBtn.disabled = false;
          
          // Send message to Figma to resize
          if (typeof parent !== 'undefined' && parent !== window) {
            parent.postMessage({
              pluginMessage: { type: 'maximize' }
            }, '*');
          }
          
          // Resize chart after maximizing
          setTimeout(() => {
            if (chart) chart.resize();
          }, 100);
        }
      }

      function exportChart() {
        if (!chart) return;
        
        try {
          const svgData = chart.renderToSVGString();
          const width = parseInt(document.getElementById('chart-width').value);
          const height = parseInt(document.getElementById('chart-height').value);
          
          if (typeof parent !== 'undefined' && parent !== window) {
            parent.postMessage({
              pluginMessage: {
                type: 'insert-chart',
                svgData,
                width,
                height,
                chartType: currentChartType + ' (enhanced)'
              }
            }, '*');
            console.log('üì§ Chart exported to Figma');
          } else {
            navigator.clipboard.writeText(svgData).then(() => {
              alert('SVG copied to clipboard!');
            }).catch(() => {
              console.log('SVG Data:', svgData.substring(0, 100) + '...');
              alert('Chart data logged to console');
            });
          }
        } catch (error) {
          console.error('Export error:', error);
          alert('Export failed: ' + error.message);
        }
      }

      // Initialize the plugin
      initializePlugin();
    </script>
  </body>
</html>